// Copyright Â© 2019 Marton Magyar

// SPDX-License-Identifier: MIT
// see https://spdx.org/licenses/

package cmd

import (
  "bin2tap/tapfile"
  "bufio"
  "errors"
  "fmt"
  "io/ioutil"
  "log"
  "os"
  "path/filepath"
  "strings"

  "github.com/spf13/cobra"
)

var FlagAddress uint
var SourcePath string
var MaxUint int
var OutName string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
  Use:   "bin2tap binfile [tapfile]",
  Short: "A Z80 binary file to ZX Spectrum TAP file converter",
  Long: `Converts .bin files generated by an assembler into .tap files
which can be loaded by emulators. Loading address must be given.
This will work for code only, the TAP data block type will be 'machine code'.

Usage: bin2asm binfile [tapfile] [flags]
Example: bin2asm myprog.bin -a 32768`,
  Run: func(cmd *cobra.Command, args []string) {

    inDir, inName := filepath.Split(args[0])
    base := strings.TrimSuffix(inName, filepath.Ext(inName))
    f, err := os.Open(inName)
    if err != nil {
      log.Fatal(err)
    }
    defer f.Close()

    b, err := tapfile.NewBINdata(base, f, uint16(FlagAddress))
    if err != nil {
      log.Fatal(err)
    }

    if len(OutName) < 1 {
      OutName = inDir + base + ".tap"
    }

    inFile, err := os.Open(args[0])
    if err != nil {
      log.Fatal(err)
    }
    defer inFile.Close()

    log.Println("Writing to file", OutName)

    outFile, err := os.Create(OutName)
    if err != nil {
      log.Fatal(err)
    }
    defer outFile.Close()

    w := bufio.NewWriter(outFile)
    t := tapfile.NewTAPfileBlockWriter(w)

    b.Write(t)

    //log.Println("buffered bytes:", w.Buffered())

    w.Flush()
  },
  Args: rootArgsValidator,
  //cobra.RangeArgs(1,2)
}

func existsBinFile(f string) bool {

  info, err := os.Stat(f)

  if os.IsNotExist(err) {
    return false
  }
  if info.IsDir() {
    return false
  }
  if strings.Compare(filepath.Ext(f), ".bin") != 0 {
    return false
  }

  return true
}

func isTapFile(f string) (bool, error) {
  // Check if file already exists
  if _, err := os.Stat(f); err == nil {
    return true, nil
  }

  // Attempt to create it
  var d []byte
  if err := ioutil.WriteFile(f, d, 0644); err == nil {
    os.Remove(f) // And delete it
    return true, nil
  } else {
    return false, err
  }

  return false, nil
}

func rootArgsValidator(cmd *cobra.Command, args []string) error {

  if len(args) < 1 {
    return errors.New("requires at least one argument")
  }
  if len(args) > 2 {
    return errors.New("requires not more than two arguments")
  }
  if !existsBinFile(args[0]) {
    return fmt.Errorf("first argument is not a .bin file: %s", args[0])
  }
  if len(args) > 1 {
    if b, err := isTapFile(args[1]); !b {
      OutName = ""
      if err == nil {
        return fmt.Errorf("second argument is not a valid .tap file name: %s", args[1])
      } else {
        log.Println("second argument is not a valid .tap file name: %s", args[1])
        return err
      }
    }
    OutName = args[1]
  }

  return nil
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
  if err := rootCmd.Execute(); err != nil {
    fmt.Println(err)
    os.Exit(1)
  }
}

func init() {
  rootCmd.PersistentFlags().UintVarP(&FlagAddress, "address", "a", 0,
    "Starting address of binary in Z80 address space, decimmal or hex ('0x' prefix)")
  rootCmd.MarkFlagRequired("address")
  //TODO: check if implement rootCmd.NoOptDefVal("address") = MaxUint
}
